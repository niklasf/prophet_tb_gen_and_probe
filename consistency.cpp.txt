for (int wtm = 0; wtm <= 1; ++wtm) {
        if (wtm) {
            LOSS_EGTB = WTM_EGTB;
            LOSS_COLOR = WHITE;
            CAPTURE_EGTBs = BTM_EGTBs;
        } else {
            LOSS_EGTB = BTM_EGTB;
            LOSS_COLOR = BLACK;
            CAPTURE_EGTBs = WTM_EGTBs;
        }


        #pragma omp parallel for num_threads(nthreads) schedule(static,64)
        for (uint64_t ix = 0; ix < LOSS_EGTB->num_pos; ix++) {
            EGPosition pos;
            pos.reset();
            pos_at_ix(pos, ix, LOSS_COLOR, wpieces, bpieces, LOSS_EGTB->num_nonep_pos, LOSS_EGTB->num_ep_pos);

            int16_t tb_val = LOSS_EGTB->TB[ix];
            if (tb_val == UNUSED) continue;

            assert (!pos.sntm_in_check());
            if (ix > LOSS_EGTB->num_nonep_pos) assert (pos.check_ep(pos.ep_square()));

            EGMoveList movelist = EGMoveList<FORWARD>(pos);
            if (movelist.size() == 0) {
                if (pos.stm_in_check()) {
                    assert(tb_val == LOSS_IN(0));
                } else {
                    assert(tb_val == 0);
                }

            } else {
                
                int16_t max_val = LOSS_IN(0);
                for (Move move : movelist) {
                    UndoInfo u = pos.do_move(move);
                    PieceType promotion = move.type_of() == PROMOTION ? move.promotion_type() : NO_PIECE_TYPE;
                    EGTB* cap_egtb = CAPTURE_EGTBs[promotion][u.captured];
                    uint64_t fwd_ix = ix_from_pos(pos, cap_egtb->num_nonep_pos, cap_egtb->num_ep_pos);
                    max_val = std::max(max_val, (int16_t) -cap_egtb->TB[fwd_ix]);
                    pos.undo_move(move, u);
                }

                if (max_val > 0) {
                    max_val--;
                }
                if (max_val < 0) {
                    max_val++;
                }

                assert(tb_val == max_val);
            }
        }
    }